################################################################################
# Reports Utilities
################################################################################
#' 1. import.reports; Import all the reports from the dest folder
#' 2. metadata_2_list; conver metadata into a nested list
#' 3. reshape_metadata_2_long_format; Conver metadata file to a long DF
#' 4. AUC_by_curve_integration; calculate the AUC of a curv
#' 


##################
# import.reports #
##################
import.reports <- function(reports_folder="./reports")
{
    # List the (csv) reports in the folder
    reports_list = list.files(pattern="[.]csv$", path=reports_folder, full.names=TRUE)
    
    
    # Phrase the reports names
    reports_metadata = data.frame(DATABASE_NAME=NA)
    for(k in 1:length(reports_list)){
        #' Find the indices of the metadata in the file name.
        #' The metadata is encapsulated between () (i.e. round brackets)
        index_metadata = gregexpr("\\((.*?)\\)", reports_list[k], TRUE)
        #' Check that the number of sub string composing the file name is as 
        #' defined in reports_metadata
        #stopifnot(ncol(reports_metadata)==length(index_metadata[[1]]))
        
        ## Extract the sub string to the metadata data frame
        for(l in 1:ncol(reports_metadata)){
            match_start  = index_metadata[[1]][l]
            match_length = attributes(index_metadata[[1]])$match.length[l]
            reports_metadata[k,l] = substr(reports_list[k],
                                           match_start+1,
                                           match_start+match_length-2)
        } # end extracting sub strings
    } # end extracting list_metadata
    
    
    ## Bind reports and add meta data
    reports = c()
    for(r in 1:length(reports_list)) 
    {
        report = data.table::fread(reports_list[r])
        report = as.data.frame(report)
        report[,"DATABASE_NAME"] = reports_metadata[r,"DATABASE_NAME"]
        reports = rbind(reports, report)
    } # end binding reports with metadata
    
    
    return(reports)
} # import.reports


###################
# metadata_2_list #
###################
#' @param report_metadata; data frame 
#' @return nested list
metadata_2_list <- function(report_metadata)
{
    ##############################
    # Remove unnecessary columns #
    ##############################
    report_metadata = report_metadata[,!names(report_metadata) %in% c("Strategy","QueryMethod")]
    
    
    ################
    # Ground Truth #
    ################
    # Extract the ground truth
    GT_vector = report_metadata[1,report_metadata[1,] %in% c(-1,1)]
    GT_vector = ifelse(GT_vector==-1,"majority","minority")
    GT_vector = factor(GT_vector)
    # Remove the ground truth from the probability matrix
    report_metadata = report_metadata[-1,]
    
    
    ##################
    # Pre-processing #
    ##################
    # Convert all the columns which are not estimated probabilities into factor type
    # col_names = names(report_metadata)[!names(report_metadata) %in% paste0("X",1:ncol(report_metadata))]
    # report_metadata[,col_names] = lapply(report_metadata[,col_names] , factor)
    # Arrange the data
    report_metadata = dplyr::arrange(report_metadata,DATABASE_NAME,Imb.R,Policy)
    
    
    #####################################
    # Convert metadata to a nested list #
    #####################################
    combinations = unique(report_metadata[,c("DATABASE_NAME","Imb.R","Policy","Repetition")])
    comb_list = list()
    for(i in 1:nrow(combinations)){
        # Subset the data
        comb = combinations[i,]
        chosen_DATABASE_NAME = comb[1,"DATABASE_NAME"]
        chosen_Imb.R         = comb[1,"Imb.R"]
        chosen_Policy        = comb[1,"Policy"]
        chosen_Repetition    = as.numeric(comb[1,"Repetition"])
        cat("\n#","Convert metadata to a nested list",i,"/",nrow(combinations))
        
        indicator_col = names(report_metadata)[names(report_metadata) %in% paste0("X",1:ncol(report_metadata))]
        indicator_row = with(report_metadata,DATABASE_NAME %in% chosen_DATABASE_NAME &
                                 Imb.R %in% chosen_Imb.R &
                                 Policy %in% chosen_Policy &
                                 Repetition %in% chosen_Repetition)
        sub_matrix = data.matrix(report_metadata[indicator_row,indicator_col])
        
        # Store sub matrix in the nested list
        comb_list[[chosen_Policy]][[chosen_Repetition]] = sub_matrix
        
    }# end for combinations
    # str(comb_list)
    # dim(comb_list[["max_tuv-random"]][[1]])
    
    
    ######################
    # Store Ground Truth #
    ######################
    comb_list[["Ground Truth"]] = GT_vector
    
    
    return(comb_list)
} # metadata_2_list


##################################
# reshape_metadata_2_long_format #
##################################
#' @reports r=1,...,R are the repetitions number
#' @Imb.R
#' @Repetition r=1,...,R are the repetitions number
#'
reshape_metadata_2_long_format <- function(metadata_list,
                                           Policy,
                                           Repetition)
{
    prob_reshape = data.frame()
    ############################
    # Extract the ground truth #
    ############################
    GroundTruth_vector = metadata_list[["Ground Truth"]]
    
    
    ###############################
    # Extract the chosen metadata #
    ###############################
    if(is.na(Policy)) Policy = setdiff(names(metadata_list),"Ground Truth")
    for(chosen_Policy in Policy)
    {
        if(is.na(Repetition)) Repetition = 1:length(metadata_list[[chosen_Policy]])
        for(chosen_Repetition in Repetition)
        {
            ## Find the desired list
            prob_matrix = t(metadata_list[[chosen_Policy]][[chosen_Repetition]])
            
            
            ##########################
            # Create long data.frame #
            ##########################
            ## Extract probabilities
            rownames(prob_matrix) = NULL
            colnames(prob_matrix) = NULL
            ## Create long data frame
            n      = nrow(prob_matrix)
            epochs = ncol(prob_matrix)
            for(epoch in 0:(epochs-1)){
                prob_reshape = rbind(prob_reshape,
                                     data.frame(Policy=chosen_Policy,
                                                Repetition=chosen_Repetition,
                                                Epoch=epoch,
                                                ID=1:n,
                                                Est=prob_matrix[,epoch+1],
                                                Class=GroundTruth_vector))
            }# end for epoch
        }# end for Repetition
    }# end for Policy
    
    
    # # > head(prob_reshape)
    #   Policy Repetition Epoch ID   Est    Class
    # 1 Random          6     0  1 0.083 majority
    # 2 Random          6     0  2 0.071 minority
    # 3 Random          6     0  3 0.088 majority
    # 4 Random          6     0  4 0.087 majority
    # 5 Random          6     0  5 0.086 minority
    # 6 Random          6     0  6 0.093 majority
    
    
    return(prob_reshape) 
}# reshape_metadata_2_long_format


############################
# AUC_by_curve_integration #
############################
#' @x x coordinate
#' @y y coordinate
#'
AUC_by_curve_integration <- function(x,y)
{
    S = vector("numeric",length(x)-1)
    for(i in 2:length(x)){
        a = x[i-1]
        b = x[i]
        f_a = y[i-1]
        f_b = y[i]
        # Trapezoidal rule
        # https://en.wikipedia.org/wiki/Trapezoidal_rule
        S[i] = ((b-a)/2)*(f_a+f_b)
    }
    return(sum(S) / (diff(range(x))*diff(range(y))))
} #end AUC_by_curve_integration