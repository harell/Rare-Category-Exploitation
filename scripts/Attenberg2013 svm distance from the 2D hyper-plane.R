################################################################################
# Attenberg2013 - 3.1. Support Vector Machines: Distance from the 2D hyper-plane
################################################################################
#' References
#' [1] Support vector machine From Joao Neto
#' <http://www.di.fc.ul.pt/~jpn/r/svm/svm.html>
#' 

##################
# Initialization #
##################
rm(list = ls()); cat("\014")
library(e1071) # for svm() 
library(ggplot2) # for visualisation
library(plotly)  # for interactive visualisation


###########################
# Generating the data-set #
###########################
n = 400
Imb.R = 1/10
n_majority = round(n/(1+Imb.R))
n_minority = n-n_majority
set.seed(2016)
x_majority = MASS::mvrnorm(n_majority, mu=rep(-1,2), Sigma=diag(rep(1,2)))
x_minority = MASS::mvrnorm(n_minority, mu=rep(+1,2), Sigma=diag(rep(1,2)))

x     = rbind(x_majority, x_minority)
label = factor(c(rep("majority",n_majority),rep("minority",n_minority)))
A     = data.frame(x,label)

# fig_total     <- ggplot(A, aes(x=X1)) + geom_density()
fig_separated_1 <- ggplot(A, aes(x=X1, col=label)) + geom_density(aes(group=label))
fig_separated_2 <- ggplot(A, aes(x=X2, col=label)) + geom_density(aes(group=label))


##########################
# Splitting the data-set #
##########################
#' 70%/30% split
# set.seed(2016)
# index_train = sample(n,round(0.7*n))
#' Fix number of instances in the training set
set.seed(2016)
index_train = sample(n,100)
#' Split into training and test sets
A_tr = A[+index_train,]
A_te = A[-index_train,]
#' How many majority/minority each set includes?
table(A_tr$label); prop.table(table(A_tr$label))
table(A_te$label); prop.table(table(A_te$label))


#########################################
# Fitting SVM model on the training-set #
#########################################
svm_model <- e1071::svm(label~X1+X2, data=A_tr, 
                        type='C-classification', kernel='linear',
                        scale=T, probability=TRUE)


##################################
# Reconstructing the hyper-plane #
##################################
SV_info = data.frame()
# Get parameters of hiperplane
w  = t(svm_model$coefs) %*% svm_model$SV
w1 = w[,1]; w2 = w[,2]
b  = svm_model$rho
# Get the support vectors
SV = A_tr[svm_model$index,]
# Display information about the support vectors 
SV_info[1,"SVp"]  = table(SV$label)["minority"] # counts
SV_info[1,"SVn"]  = table(SV$label)["majority"] # counts
SV_info[1,"SVpp"] = prop.table(table(SV$label))["minority"] # percentage
SV_info[1,"SVnp"] = prop.table(table(SV$label))["majority"] # percentage
SV_info[1,"SVr"]  = SV_info[1,"SVp"]/SV_info[1,"SVn"] # ratio = SV-/SV+
rm(SV)
# Flag the support vectors
A_tr[,"SV"] = "No"
A_tr[svm_model$index,"SV"] = "Yes"
A_tr$SV = factor(A_tr$SV)


############################
# Predicting the train-set #
############################
y_hat = predict(svm_model, A_tr, probability=TRUE)
y_hat = attr(y_hat, "probabilities")
A_tr$class = ifelse(as.numeric(A_tr$label)==1,-1,1)
A_tr$minority_probability = as.vector(y_hat[,"minority"]) 
A_tr$uncertainty_rank = rank(abs(A_tr$minority_probability-0.5))


###########################
# Predicting the test-set #
###########################
y_hat = predict(svm_model, A_te, probability=TRUE)
y_hat = attr(y_hat, "probabilities")
A_te$class = ifelse(as.numeric(A_te$label)==1,-1,1)
A_te$minority_probability = as.vector(y_hat[,"minority"]) 
A_te$uncertainty_rank = rank(abs(A_te$minority_probability-0.5))


####################
# Evaluating model #
####################
pred    = ROCR::prediction(A_te$minority_probability, A_te$label)
## AUC
AUC_obj = ROCR::performance(pred,"auc")
AUC_obj@y.values[[1]]
## PRBEP (Precision Recall Break-Even Point)
PRBEP_obj = ROCR::performance(pred,"prbe")
max(PRBEP_obj@y.values[[1]])


#################
# Visualisation #
#################
# ---------------------------------------------------------------------------- #
# Full-dataset
plot(svm_model,A)
xlim = range(A$X1)
ylim = range(A$X2)
# ---------------------------------------------------------------------------- #
# Training-set
## Density Plot
fig_train_density <- ggplot(A_tr, aes(x=minority_probability)) + 
    geom_density() + xlim(0,1)
ggplotly(fig_train_density)
## Scatter Plot
fig_train_scatter <- ggplot(A_tr, aes(X1, X2, label=uncertainty_rank)) + 
    ggtitle("Visualisation of the training-set") + 
    # Training set points
    geom_point(aes(colour=minority_probability, shape=label), size=2) + 
    scale_colour_gradient(low="red", high="green") + 
    # Test set points
    #geom_point(data=A_te, aes(X1, X2, shape=label), size=2) + 
    # Rank (display only ranks with a value below a certain threshold)
    geom_text(aes(label=ifelse(uncertainty_rank<=10, as.character(uncertainty_rank), ''))) +
    # Hyper=plane
    geom_abline(intercept=-b, slope=-w1/w2) +
    # Plot attributes
    xlim(xlim) + ylim(ylim)
ggplotly(fig_train_scatter)
# ---------------------------------------------------------------------------- #
# Test-set
## Density Plot
fig_test_density <- ggplot(A_te, aes(x=minority_probability)) + 
    geom_density(trim = TRUE) + xlim(0,1)
ggplotly(fig_test_density)
## Scatter Plot
fig_test_scatter <- ggplot(A_te, aes(X1, X2, label=uncertainty_rank)) + 
    ggtitle("Visualisation of the test-set") + 
    geom_point(aes(colour=minority_probability, shape=label), size=2) + 
    scale_colour_gradient(low="red", high="green") + 
    # Rank (display only ranks with a value below a certain threshold)
    geom_text(aes(label=ifelse(uncertainty_rank<=10, as.character(uncertainty_rank), ''))) +
    # Hyper=plane
    geom_abline(intercept=-b, slope=-w1/w2) + 
    # Plot attributes
    xlim(xlim) + ylim(ylim)
ggplotly(fig_test_scatter)


#######################
# Choosing the cutoff #
#######################
prob_quantile = round(quantile(A_te$minority_probability,c(0.99)),3)
cat("\n",rep("#",40),
    "\n", "# Test-set probability statistics:",
    "\n", "# mean = ", round(mean(A_te$minority_probability),3),
    "\n", "# median = ", round(median(A_te$minority_probability),3),
    "\n", "# 99% quantile = ", prob_quantile,
    sep="")






